package com.ylsh.jvm.memory;

import java.util.ArrayList;
import java.util.List;

/**
 * 栈上的变量持有堆上的对象引用，两种引用：
 *  1直接指针，指向堆上对象的地址，（hotspot使用此），堆上实例对象持有永久代Class对象的引用
 *  句柄引用，指向一块区域，此区域有一个指向实例对象的指针和一个指向元数据（Class）的的指针.如果发生垃圾回收，这里的实例指针需要从新维护
 *
 * 基本数据类型是直接存在于栈上的
 *
 * 虚拟机栈：Stack Frame 栈帧
 * 程序计数器：Program Counter 记录程序执行到哪里，和下一步该执行哪一步，当程序被挂起时，记录程序执行的位置，当程序恢复时，接着之前的地方执行
 * 本地方法栈：主要用于处理本地方法
 * 堆（heap）:jvm管理的最大的一块内存空间，与堆相关的一个重要概念是垃圾收集器。现代几乎所有的垃圾收集器都是采用分代收集算法，所以，堆空间
 * 也基于这一点进行了相应的划分：新生代与老年代。Eden空间，From Survivor空间与To Survivor空间。
 * 方法区（mehod area）:存储信息。永久代（Permanent Centeration）,从jdk1.8开始，已经彻底废弃来永久代，使用元空间（meta space）
 * 运行时常量池：方法去的一部分内容
 * 直接内存：Direct Memory。与java nio 密切相关，jvm通过堆上的direcByteBuffer来操作直接内存。
 *
 * 关于java对象创建的过程：
 * new 关键字创建兑现的3个步骤：
 * 1 在堆内存中创建出
 * 2 为对象的实例成员变量赋初值。
 * 3 将对象的引用返回
 *
 * 指针碰撞（前提是堆中的空间通过一个指针进行分割，一侧是已经被占用的空间，另一侧是未被占用的空间）。新对象的创建申请内存空间，通过指针向未被使用的一侧移动。
 * 空闲列表（前提是堆内存空间中已被使用与未被使用的空间是交织在一起的，这时，虚拟机就需要通过一个列表来记录那些空间是可以使用的，那些空间是已被使用的，接下来
 * 找出可以容纳下新创建对象的且未被使用的空间，在此空间存放该对象，同时还要修改列表上的记录）
 *
 * 对象在内存中的布局：
 * 1 对象头
 * 2 实例数据（即我们在一个类中所声明的各项信息）
 * 3 对齐填充（可选）。对象的大小是8的倍数，如果不是8的倍数，则通过填充0，填充为8的倍数
 *
 * 引用访问对象的方式：
 * 1 使用句柄的方式
 * 2使用直接指针的方法
 *
 *
 * -Xms5m -Xmx5m -XX:+HeapDumpOnOutOfMemoryError
 *
 */
public class Sty001 {

    public static void main(String[] args){
        List<Sty001> list = new ArrayList<>();
        while(true){
            list.add(new Sty001());
            /**
             * 查看此方法说明。在gc的时候，jvm会尽量丢弃不用的对象，实现堆内存
             * 重复利用。一般jvm进行垃圾收集是由一个专门的线程进行处理，个人不要
             * 在代码中显式的进行调用。
             */
            System.gc(); //添加这行之后，内存就不会溢出了
            System.out.println("1");
        }
    }
}
