### java枚举的学习

```
  TrafficLight.jad 使用jad反编译工具，反编译TrafficLight.class，看枚举
是如何实现的。所谓枚举其实就是一个语法糖
特征：
类被final修饰，避免被继承，字段被final修饰，避免被改变
在类初始化阶段，通过静态代码块进行实例创建 和装载实例的数组
```

用途
- 可以用来创建单例。因为 类构造器只能被一个线程在类加载的初始化阶段进行执行，effectiv java 作者提倡

 xa 两阶段提交  
 事务协调者 单点  
 数据库 多点  
 
 1 比较消耗数据库宝贵资源  
 2存在实物协调者单点故障问题  
 3数据库 会因为网络原因部分接收到消息，部分没有接收到消息
 
## 为什么这么说呢？关键在于性能问题。
```
  Synchronized关键字会让没有得到锁资源的线程进入BLOCKED状态，而后在争夺到锁资源后恢复为RUNNABLE状态，
 这个过程中涉及到操作系统用户模式和内核模式的转换，代价比较高。  
  尽管Java1.6为Synchronized做了优化，增加了从偏向锁到轻量级锁再到重量级锁的过度，
 但是在最终转变为重量级锁之后，性能仍然较低。  
  从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。
CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。

CAS的缺点：
1.CPU开销较大
在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。

2.不能保证代码块的原子性
CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。
例如：i++ 问题 ，代码块中的三个变量 实现原子操作
3.ABA问题
这是CAS机制最大的问题所在。
什么是ABA问题？怎么解决？我们下一期来详细介绍
AtomicStampedReference
```

### zookeeper
```
    分布式协调服务。
    - 全局配置共享
    - 锁资源协调
    - 提供命名服务
```


 
 ###蓝绿部署和滚动部署
  蓝绿部署，其中一个先下线进行部署  
  滚动部署 不线下，进行部分更换
  # 词汇
  extract 提取    
  candidate 候选人   
  holder 持有人；固定器    
  decoreate 装饰
  